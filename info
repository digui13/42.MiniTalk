write
malloc
free

signal
sigemptyset
sigaddset
sigaction

kill
getpid

pause
sleep
usleep
exit




signal

    sig_t signal(int sig, sig_t func);

    This signal() facility is a simplified interface to the more general sigaction(2) facility.

     Signals allow the manipulation of a process from outside its domain, as well as allowing the process to manipulate itself or copies of itself (children).  There are two
     general types of signals: those that cause termination of a process and those that do not.  Signals which cause termination of a program might result from an irrecoverable
     error or might be the result of a user at a terminal typing the `interrupt' character.  Signals are used when a process is stopped because it wishes to access its control
     terminal while in the background (see tty(4)).  Signals are optionally generated when a process resumes after being stopped, when the status of child processes changes, or
     when input is ready at the control terminal.  Most signals result in the termination of the process receiving them, if no action is taken; some signals instead cause the
     process receiving them to be stopped, or are simply discarded if the process has not requested otherwise.  Except for the SIGKILL and SIGSTOP signals, the signal() func-
     tion allows for a signal to be caught, to be ignored, or to generate an interrupt.  
     
    These signals are defined in the file <signal.h>:

     No    Name         Default Action       Description
     1     SIGHUP       terminate process    terminal line hangup
     2     SIGINT       terminate process    interrupt program
     3     SIGQUIT      create core image    quit program
     4     SIGILL       create core image    illegal instruction
     5     SIGTRAP      create core image    trace trap
     6     SIGABRT      create core image    abort program (formerly SIGIOT)
     7     SIGEMT       create core image    emulate instruction executed
     8     SIGFPE       create core image    floating-point exception
     9     SIGKILL      terminate process    kill program
     10    SIGBUS       create core image    bus error
     11    SIGSEGV      create core image    segmentation violation
     12    SIGSYS       create core image    non-existent system call invoked
     13    SIGPIPE      terminate process    write on a pipe with no reader
     14    SIGALRM      terminate process    real-time timer expired
     15    SIGTERM      terminate process    software termination signal
     16    SIGURG       discard signal       urgent condition present on socket
     17    SIGSTOP      stop process         stop (cannot be caught or ignored)
     18    SIGTSTP      stop process         stop signal generated from keyboard
     19    SIGCONT      discard signal       continue after stop
     20    SIGCHLD      discard signal       child status has changed
     21    SIGTTIN      stop process         background read attempted from control terminal
     22    SIGTTOU      stop process         background write attempted to control terminal
     23    SIGIO        discard signal       I/O is possible on a descriptor (see fcntl(2))
     24    SIGXCPU      terminate process    cpu time limit exceeded (see setrlimit(2))
     25    SIGXFSZ      terminate process    file size limit exceeded (see setrlimit(2))
     26    SIGVTALRM    terminate process    virtual time alarm (see setitimer(2))
     27    SIGPROF      terminate process    profiling timer alarm (see setitimer(2))
     28    SIGWINCH     discard signal       Window size change
     29    SIGINFO      discard signal       status request from keyboard
     30    SIGUSR1      terminate process    User defined signal 1
     31    SIGUSR2      terminate process    User defined signal 2



    The previous action is returned on a successful call.  Otherwise, SIG_ERR is returned and the global variable errno is set to indicate the error.



    The sig argument specifies which signal was received.  The func procedure allows a user to choose the action upon receipt of a signal.  To set the default action of the
     signal to occur as listed above, func should be SIG_DFL.  A SIG_DFL resets the default action.  To ignore the signal, func should be SIG_IGN.  This will cause subsequent
     instances of the signal to be ignored and pending instances to be discarded.  If SIG_IGN is not used, further occurrences of the signal are automatically blocked and func
     is called.

     The handled signal is unblocked when the function returns and the process continues from where it left off when the signal occurred.  Unlike previous signal facilities,
     the handler func() remains installed after a signal has been delivered.

     For some system calls, if a signal is caught while the call is executing and the call is prematurely terminated, the call is automatically restarted.  Any handler
     installed with signal(3) will have the SA_RESTART flag set, meaning that any restartable system call will not return on receipt of a signal.  The affected system calls
     include read(2), write(2), sendto(2), recvfrom(2), sendmsg(2), and recvmsg(2) on a communications channel or a low speed device and during a ioctl(2) or wait(2).  However,
     calls that have already committed are not restarted, but instead return a partial success (for example, a short read count).  These semantics could be changed with
     siginterrupt(3).

     When a process which has installed signal handlers forks, the child process inherits the signals.  All caught signals may be reset to their default action by a call to the
     execve(2) function; ignored signals remain ignored.

     If a process explicitly specifies SIG_IGN as the action for the signal SIGCHLD, the system will not create zombie processes when children of the calling process exit.  As
     a consequence, the system will discard the exit status from the child processes.  If the calling process subsequently issues a call to wait(2) or equivalent, it will block
     until all of the calling process's children terminate, and then return a value of -1 with errno set to ECHILD.

     See sigaction(2) for a list of functions that are considered safe for use in signal handlers.


sigemptyset

    int sigemptyset(sigset_t *set);

    These functions manipulate signal sets, stored in a sigset_t.  Either sigemptyset() or sigfillset() must be called for every object of type sigset_t before any other use
     of the object.

     The sigemptyset() function initializes a signal set to be empty.

    return 0


sigaddset

    int sigaddset(sigset_t *set, int signo);

    The sigaddset() function adds the specified signal signo to the signal set.

    return 0


sigaction

    int sigaction(int sig, const struct sigaction *restrict act, struct sigaction *restrict oact);

    The system defines a set of signals that may be delivered to a process.  Signal delivery resembles the occurrence of a hardware interrupt: the signal is normally blocked
     from further occurrence, the current process context is saved, and a new one is built.  A process may specify a handler to which a signal is delivered, or specify that a
     signal is to be ignored.  A process may also specify that a default action is to be taken by the system when a signal occurs.  A signal may also be blocked, in which case
     its delivery is postponed until it is unblocked.  The action to be taken on delivery is determined at the time of delivery.  Normally, signal handlers execute on the cur-
     rent stack of the process.  This may be changed, on a per-handler basis, so that signals are taken on a special signal stack.

     Signal routines normally execute with the signal that caused their invocation blocked, but other signals may yet occur.  A global signal mask defines the set of signals
     currently blocked from delivery to a process.  The signal mask for a process is initialized from that of its parent (normally empty).  It may be changed with a
     sigprocmask(2) call, or when a signal is delivered to the process.

     When a signal condition arises for a process, the signal is added to a set of signals pending for the process.  If the signal is not currently blocked by the process then
     it is delivered to the process.  Signals may be delivered any time a process enters the operating system (e.g., during a system call, page fault or trap, or clock inter-
     rupt).  If multiple signals are ready to be delivered at the same time, any signals that could be caused by traps are delivered first.  Additional signals may be processed
     at the same time, with each appearing to interrupt the handlers for the previous signals before their first instructions.  The set of pending signals is returned by the
     sigpending(2) system call.  When a caught signal is delivered, the current state of the process is saved, a new signal mask is calculated (as described below), and the
     signal handler is invoked.  The call to the handler is arranged so that if the signal handling routine returns normally the process will resume execution in the context
     from before the signal's delivery.  If the process wishes to resume in a different context, then it must arrange to restore the previous context itself.

     When a signal is delivered to a process a new signal mask is installed for the duration of the process' signal handler (or until a sigprocmask(2) system call is made).
     This mask is formed by taking the union of the current signal mask set, the signal to be delivered, and the signal mask associated with the handler to be invoked.

     The sigaction() system call assigns an action for a signal specified by sig.  If act is non-zero, it specifies an action (SIG_DFL, SIG_IGN, or a handler routine) and mask
     to be used when delivering the specified signal.  If oact is non-zero, the previous handling information for the signal is returned to the user.

     Once a signal handler is installed, it normally remains installed until another sigaction() system call is made, or an execve(2) is performed.  A signal-specific default
     action may be reset by setting sa_handler to SIG_DFL.  The defaults are process termination, possibly with core dump; no action; stopping the process; or continuing the
     process.  See the signal list below for each signal's default action.  If sa_handler is SIG_DFL, the default action for the signal is to discard the signal, and if a sig-
     nal is pending, the pending signal is discarded even if the signal is masked.  If sa_handler is set to SIG_IGN current and pending instances of the signal are ignored and
     discarded.

    Options may be specified by setting sa_flags.  The meaning of the various bits is as follows:

           SA_NOCLDSTOP    If this bit is set when installing a catching function for the SIGCHLD signal, the SIGCHLD signal will be generated only when a child process exits,
                           not when a child process stops.

           SA_NOCLDWAIT    If this bit is set when calling sigaction() for the SIGCHLD signal, the system will not create zombie processes when children of the calling process
                           exit.  If the calling process subsequently issues a wait(2) (or equivalent), it blocks until all of the calling process's child processes terminate,
                           and then returns a value of -1 with errno set to ECHILD.

           SA_ONSTACK      If this bit is set, the system will deliver the signal to the process on a signal stack, specified with sigaltstack(2).

           SA_NODEFER      If this bit is set, further occurrences of the delivered signal are not masked during the execution of the handler.

           SA_RESETHAND    If this bit is set, the handler is reset back to SIG_DFL at the moment the signal is delivered.

           SA_RESTART      See paragraph below.

           SA_SIGINFO      If this bit is set, the handler function is assumed to be pointed to by the sa_sigaction member of struct sigaction and should match the prototype
                           shown above or as below in EXAMPLES.  This bit should not be set when assigning SIG_DFL or SIG_IGN.

kill

    The kill utility sends a signal to the processes specified by the pid operands.

     Only the super-user may send signals to other users' processes.

getpid

    #include <unistd.h>

    pid_t   getpid(void);

    returns the process ID of the calling process.  The ID is guaranteed to be unique and is useful for constructing temporary file names.



https://www.youtube.com/watch?v=jF-1eFhyz1U

https://www.youtube.com/watch?v=PErrlOx3LYE

https://www.youtube.com/watch?v=7ud2iqu9szk

https://www.youtube.com/watch?v=3MZjaZxZYrE

https://www.youtube.com/watch?v=5We_HtLlAbs

https://www.youtube.com/watch?v=83M5-NPDeWs